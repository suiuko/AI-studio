#### 2.1 数据集包含 1000 个样本，其中 500 个正例、 500 个反例，将其划分为包含 70% 样本的训练集和 30% 样本的测试集用于留出法评估，估算有多少种划分方式。
**答：**   

排列组合问题。   
>训练/测试集的划分要尽可能保存数据分布一致   

那么训练集中应该包括 350 个正例和 350 个反例，剩余的作测试集，那么划分方式应该有 $ (x_{500}^{350})^{2} $种。   

---

#### 2.2 数据集包含 100 个样本，其中正反例各一半，假定学习算法所产生的模型是将新样本预测为训练样本数较多的类别（训练样本数相同时进行随机猜测），试给出用10折交叉验证法和留一法分别对错误率进行评估所得的结果。
**答：**   

10 折交叉验证：交叉验证中每个子集数据分布要尽可能保持一致，那么本题中 10 次训练中每次正反例各占 45 ，模型训练结果随机猜测，错误率期望为 50%。

留一法：若留出样本为正例，训练集中则有 50 个反例和 49 个正例，模型预测为反例；反之留出样本为反例，模型预测为正例，错误率为 100%。

---

#### 2.3 若学习器A的F1值比学习器B高，试析A的BEP值是否也比B高。
**答：**   

先看看F1值的定义，   
![1](https://github.com/han1057578619/MachineLearning_Zhouzhihua_ProblemSets/blob/master/ch2--%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/image/1.jpg)   
$ F1 = (2 * P * R) / (P + R) $ ，其中 $ P = TP / (TP + FP) $ 即查准率（Precision），
【预测为正例且真实为正例的数量】/【预测为正例的数量】，说白了关心预测为正样本时的准确率；
$ R = TP / (TP + FN) $ 即查全率（又称召回率Recall），【预测为正例且真实为正例的数量】/【真实为正例的数量】。
F1值计算中对查准率和查全率都同等重视。   

再看看BEP值

首先目前很多分类算法输出的都是0-1之间的一个概率值，比如逻辑回归、XGBoost等，
分类时的做法是预定一个阈值（典型为0.5），若对样本的输出大于此阈值则归为1类（即正例），
那么根据样本的输出值从大到小排序（下文简称为“样本的排序”），排在最前面的即可理解为最有可能为正例的样本，
而排在最后的是最不可能为正例的样本。从前往后，逐个将样本预测为正例（即把当前样本的输出值定于为阈值，小于阈值的都为反例），
每次计算当前的查准率和查全率，即可得到查全率为横坐标查准率为纵坐标上的一个点，在将所有点按顺利连接后即可得到“P-R曲线”，
而BEP（即Break-Event Point，平衡点）是在查全率=查准率时的取值。   
![2](https://github.com/han1057578619/MachineLearning_Zhouzhihua_ProblemSets/blob/master/ch2--%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/image/2.jpg)   
讨论：   

从定义上看，F1值是在阈值固定时，将所有样本分类完成后，综合查全率和查准率得出的值；
而BEP值则是寻求一个阈值使得查全率和查准率相同的情况下得到的（此时BEP = 查全率 = 查准率）。

也就是说BEP值和“样本的排序”紧密相关的，而和样本的预测值大小无关，同样的排序，
即使将所有预测值同时乘以 0.5 ，其BEP值也是相同的；但是对于F1值，所有样本都将预测为负例（假定阈值为0.5时），此时F1值为0。

回到题目本身，“若学习器A的F1值比学习器B高，则A的BEP值比B高”，那么若能找到两个学习器BEP值相同，
而F1值不同，则题目命题就不成立了。那从上面的讨论中已经有了答案了，
想象一下学习器A对样本输出值均为学习器B的两倍，两者BEP值是相同的，A的输出在（0,1）之间，
而B的输出在（0,0.5）之间，此时B的 F1 值为0，A的 F1 值是在0-1之间。所以原命题不成立。

ps.个人从直觉上BEP值和F1值是没有明确关系的，在讨论过程中拿“输出值乘以0.5”为例，
事实上，想象一下，一串固定排序的点(模型的输出概率值)，只在0-1之间同时前进或者后退
（每个点前进步长可以不一样，但是排序不变），其BEP值也不会发生变化，而F1值是不断变化的。

---


#### 2.4 试述真正例率（TPR）、假正例率（FPR）与查准率（P）、查全率（R）之间的联系。
**答：**   

![3](https://github.com/han1057578619/MachineLearning_Zhouzhihua_ProblemSets/blob/master/ch2--%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/image/3.jpg)   
查全率： $ R = TP / (TP + FN) $ 。【预测为正例且真实为正例的数量】/【真实为正例的数量】   
查准率： $ P = TP / (TP + FP) $ 。【预测为正例且真实为正例的数量】/【预测为正例的数量】   
真正例率（TPR）：同查全率   
假正例率（FPR）： $ FP / (TN + FP) $ 。即所有反例中被预测为正例的比率。   

---


#### 2.5 试证明(2.22)AUC=1−lrank
**答：**   

显然，在ROC曲线中，一条横线对应一个（或多个）负样本 $ x_{i}^{-} $ ， 一条竖线对应一个（或多个）正样本 $ x_{j}^{+} $ ， 
而一条斜线则对应多个正负样本 $ x^{+}\_{\ast},x^{-}\_{\ast} $ ，且 $ f(x^{+}\_{*}) = f(x^{-}\_{\ast}) $ ，即样本的预测值相同。如下图所示：   
![4](https://github.com/han1057578619/MachineLearning_Zhouzhihua_ProblemSets/blob/master/ch2--%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/image/4.jpg)   
其中 $ m_{i}^{+} $ 对应一个（或多个预测值相同的）正例，而 $ m_{j} $ 对应多个预测值相同的正负例 $ x^{+}\_{\ast},x^{-}\_{\ast} $ ，
显然阴影部分的宽为 $ \frac{\sum_{x^{-}\in D^{-}} \parallel(f(x^{-}) = f(m_{j}))} {m^{-}} $ , $ m_{i}^{+} $
的纵坐标为 $ \frac{\sum_{x_{+}\in D^{+}}\parallel(f(x^{+})>f(m_{j}))}{m^{+}} $ ，而 $ m_{j} $
纵坐标为 $ \frac{\sum_{x_{+}\in D^{+}}\parallel(f(x^{+})>f(m_{j}))}{m^{+}} + \frac{\sum_{x_{+}\in D^{+}}\parallel(f(x^{+})=f(m_{j}))}{m^{+}} $ ，
于是阴影部分面积则为 $ \frac{(\sum_{x^{-}\in D^{-}} \parallel(f(x^{-}) = f(m_{j})))\ast(\sum_{x^{+}\in D^{+}} (\frac{1}{2}\parallel(f(x^{+}) = f(m_{j}))+\parallel(f(x^{+}) > f(m_{j})))} {m^{-}m^{+}} $ 

令 $ D^{-}\_{|f(D^{-})|} $ 表示预测值唯一的负例集合，即原负例集合中以预测值 $ f(x) $ 去重，
那么AUC值为： $ \sum\_{m \in D^{-}\_{|f(D^{-})|}}\frac{(\sum\_{x^{-}\in D^{-}} \parallel(f(x^{-}) = f(m)))\ast (\sum\_{x^{+}\in D^{+}} (\frac{1}{2}\parallel(f(x^{+}) = f(m))+\parallel(f(x^{+}) > f(m)))} {m^{-}m^{+}} $ 
其中 $ \sum_{m \in D^{-}\_{|f(D^{-})|}} (\sum_{x^{-}\in D^{-}} \parallel(f(x^{-}) = f(m))) \ast \sum_{x^{+}\in D^{+}} \parallel(f(x^{+}) = f(m)) = \sum_{x^{+}\in D^{+}}\sum_{x^{-}\in D^{-}} \parallel(f(x^{+}) = f(x^{-})) $

而 $ \sum_{m \in D^{-}\_{|f(D^{-})|}} (\sum\_{x^{-}\in D^{-}} \parallel(f(x^{-}) = f(m))) \ast \sum_{x^{+}\in D^{+}} \parallel(f(x^{+}) > f(m)) = \sum_{x^{+}\in D^{+}}\sum_{x^{-}\in D^{-}} \parallel(f(x^{+}) > f(x^{-})) $

于是 $ AUC = \frac{1}{m^{+}m^{-}}\sum_{x^{+}\in D^{+}}\sum_{x^{-}\in D^{-}} (\parallel(f(x^{+}) > f(x^{-})) + \frac{1}{2}\parallel(f(x^{+}) = f(x^{-}))) $

于是 $ AUC + l_{rank} = 1 $

---

#### 2.6 试述错误率和ROC曲线的联系
**答：**   

错误率是在阈值固定的情况下得出的，ROC曲线是在阈值随着样本预测值变化的情况下得出的。ROC曲线上的每一个点，都对应着一个错误率。

---

#### 2.7 试证明任意一条ROC曲线都有一条代价曲线与之对应，反之亦然
**答：**   

首先“任意一条ROC曲线都有一条代价曲线与之对应”，显然ROC曲线上每个点（FPR，TPR）都对应着下图中一条线段，取所有线段的下届，即可得到唯一的代价曲线。
![5](https://github.com/han1057578619/MachineLearning_Zhouzhihua_ProblemSets/blob/master/ch2--%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/image/5.jpg)   
反之，代价曲线实际上是一个多边形（在有限样本下），易理解，每条边都对应代价平面上一条线段，实际上从左向右遍历每一条边，即可得到ROC曲线上从左到右每一个点。

ps. ROC曲线对应着唯一条代价曲线，但是一条代价曲线可对应着多条不同的ROC曲线，
如上图中，在绿、黄、蓝三条线段交于红点时，此时去掉黄色线段代价曲线是不会发生变化的，但是ROC曲线则会少一个点。

---

#### 2.8 Min-max 规范化和z-score 规范化的优缺点。
**答：**   

- Min-max 规范化优点1、计算相对简单一点。2、当新样本进来时，只有在新样本大于原最大值或者小于原最小值时，才需要重新计算规范化之后的值。缺点在于1、容易受高杠杆点和离群点影响。
- z-score 规范化优点在于。1、对异常值敏感低。缺点在于1、计算更负责。2、每次新样本进来都需要重新计算规范化。

---

#### 2.9 简述 $ \chi^{2} $ 检验过程
**答：**  

略

---

#### 2.10 试述Friedman 检验中使用式（2.34）和（2.35）的区别。
**答：**  

略。没学过统计学。以后有机会再补。
