#### 3.1 试分析在什么情况下，在以下式子中不比考虑偏置项b。
**答：**   

在样本 $ x $ 中有某一个属性 $ x_{i} $ 为固定值时。那么此时 $ w_{i}x_{i}+b $ 等价于偏置项，此时 $ w_{i}x_{i}+b $与 $ b $等价。

---

#### 3.2 试证明，对于参数 ，对率回归（logistics回归）的目标函数（3.18）是非凸的，但其对数似然函数（3.27）是凸的。
**答：**   

3.18： $ y = \frac{1}{1 + e^{-(w^{T}x+b)}} $，

3.27：  $ l(\beta)=\sum_{i=1}^{m}lnp(y_{i}|x_{i};w, b) $。

>对实数集上的函数，可通过求二阶导数来判别：若二阶导数在区间上非负，则称为凸函数；若二阶导数在区间上恒大于 0，则称为严格凸函数。原书p54）   

对于多元函数，其Hessian matrix为半正定即为凸函数。
对于式 3.27 ，关于 $ \beta $ 的二阶导有 （原书p60）
$ \frac{\partial^{2}{l(\beta)}}{\partial{\beta}\partial{\beta^{T}}}=\sum_{i=1}^{m}\tilde{x_{i}}\tilde{x_{i}}^{T}p_{1}(\tilde{x_{i}};\beta)(1-p_{1}(\tilde{x_{i}})=XPX^{T} $，
其中第一个等号是原书中的，第二个等号中 $ X $ 为 $ (n,m) $ 矩阵，每一列对应一个样本， $ P $ 为对角矩阵， $ P_{ii}=p_{1}(\tilde{x_{i}};\beta)(1-p_{1}(\tilde{x_{i}}) $ 。

关于 $ XPX^{T} $ ，对于任意向量 $ z $ 都有：$ z^{T}XPX^{T}z = (X^{T}z)^{T}P(X^{T}z)=v^{T}Pv=\sum_{i}P_{ii}v_{i}^{2}\geq0 $ ，因此其海森矩阵为半正定。

对于式 3.18 ，这里，$ y $ 理解为标量，而 $ x $ 为 $ X $ 的列向量。则其一阶导 $ \frac{\partial{y}}{\partial{w}}=x(y-y^{2}) $ 。
二阶导 $ \frac{\partial^{2}{y}}{\partial{w}\partial{w^{T}}}=xx^{T}y(1-y)(1-2y) $（即海森矩阵），
其中 $ xx^{T} $ 秩为1，非零特征值只有一个，其正负号取决于 $ y(1-y)(1-2y) $ ，
显然当在(0,1)之间变化时，特征值正负号会发生变化，于是3.18式关于 $ w $ 的海森矩阵非半正定，因此非凸。

---

#### 3.3 编程实现对率回归，并给出西瓜数据集3.0α上的结果
**答：**   

见[3.3](https://github.com/han1057578619/MachineLearning_Zhouzhihua_ProblemSets/tree/master/ch3--%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/3.3)

---

#### 3.4 选择两个 UCI 数据集，比较 10 折交叉验证法和留一法所估计出的对率回归的错误率。
**答：**   

见[3.4](https://github.com/han1057578619/MachineLearning_Zhouzhihua_ProblemSets/tree/master/ch3--%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/3.4)

---

#### 3.5 编辑实现线性判别分析，并给出西瓜数据集 3.0α 上的结果.
**答：**   

见[3.5](https://github.com/han1057578619/MachineLearning_Zhouzhihua_ProblemSets/tree/master/ch3--%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/3.5)

---

#### 3.6 线性判别分析仅在线性可分数据上能获得理想结果，试设计一个改进方法，使其能较好地周于非线性可分数据。
**答：**   

引入核函数，原书p137，有关于核线性判别分析的介绍。

---

#### 3.7 令码长为 9，类别数为 4，试给出海明距离意义下理论最优的 ECOC二元码并证明之。
**答：**   

原书对很多地方解释没有解释清楚，把原论文看了一下《Solving Multiclass Learning Problems via Error-Correcting Output Codes》。

先把几个涉及到的理论解释一下。

首先原书中提到：

>对同等长度的编码，理论上来说，任意两个类别之间的编码距离越远，则纠错能力越强。因此，在码长较小时可根据这个原则计算出理论最优编码。

其实这一点在论文中也提到，“假设任意两个类别之间最小的海明距离为 d ，那么此纠错输出码最少能矫正 $ \left[ \frac{d-1}{2} \right] $ 位的错误。   
![1](https://github.com/han1057578619/MachineLearning_Zhouzhihua_ProblemSets/blob/master/ch3--%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/image/1.jpg)   
拿上图论文中的例子解释一下，上图中，所有类别之间的海明距离都为4，
假设一个样本正确的类别为 c1 ，那么codeword应该为 ‘0 0 1 1 0 0 1 1’，
若此时有一个分类器输出错误，变成‘0 0 0 1 0 0 1 1’，那么此时距离最近的仍然为 c1 ，
若有两个分类输出错误如‘0 0 0 0 0 0 1 1’，此时与 c1,c2 的海明距离都为2，无法正确分类。
即任意一个分类器将样本分类错误，最终结果依然正确，但如果有两个以上的分类器错误，
结果就不一定正确了。这是 $ \left[ \frac{d-1}{2} \right] $ 的由来。   

此外，原论文中提到，一个好的纠错输出码应该满足两个条件：
- 行分离。任意两个类别之间的codeword距离应该足够大。
- 列分离。任意两个分类器 $ f_{i},f_{j} $ 的输出应相互独立，无关联。这一点可以通过使分类器 f_{i} 编码与其他分类编码的海明距离足够大实现，且与其他分类编码的反码的海明距离也足够大（有点绕。）。   

第一点其实就是原书提到的，已经解释过了，说说第二点：
>如果两个分类器的编码类似或者完全一致，很多算法（比如C4.5）会有相同或者类似的错误分类，
如果这种同时发生的错误过多，会导致纠错输出码失效。（翻译原论文）

个人理解就是：若增加两个类似的编码，那么当误分类时，就从原来的1变成3，导致与真实类别的codeword海明距离增长。
极端情况，假设增加两个相同的编码，此时任意两个类别之间最小的海明距离不会变化依然为 d ，
而纠错输出码输出的codeword与真实类别的codeword的海明距离激增（从1变成3）。
所以如果有过多同时发出的错误分类，会导致纠错输出码失效。   

另外，两个分类器的编码也不应该互为反码，因为很多算法（比如C4.5，逻辑回归）对待0-1分类其实是对称的，
即将0-1类互换，最终训练出的模型是一样的。也就是说两个编码互为补码的分类器是会同时犯错的。
同样也会导致纠错输出码失效。   

当然当类别较少时，很难满足上面这些条件。
如上图中，一共有三类，那么只有 $ 2^{3}=8 $ 中可能的分类器编码 $ f_{0}-f{7} $ ，
其中后四种 $ f_{4}-f_{7} $ 是前四种的反码，都应去除，再去掉全为0的 $ f_{0} $ ，
就只剩下三种编码选择了，所以很难满足上述的条件。事实上，对于 k 种类别的分类，
再去除反码和全是0或者1的编码后，就剩下 $ 2^{k}-1 $ 中可行的编码。   

原论文中给出了构造编码的几种方法。其中一个是：   
![2](https://github.com/han1057578619/MachineLearning_Zhouzhihua_ProblemSets/blob/master/ch3--%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/image/2.jpg)   
回到题目上，在类别为4时，其可行的编码有7种，按照上述方法有：   
![3](https://github.com/han1057578619/MachineLearning_Zhouzhihua_ProblemSets/blob/master/ch3--%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/image/3.jpg)   
当码长为9时，那么 $ f_{6} $ 之后加任意两个编码，即为最优编码，
因为此时再加任意的编码都是先有编码的反码，此时，类别之间最小的海明距离都为4，不会再增加。

---

#### 3.8 ECOC 编码能起到理想纠错作用的重要条件是：在每一位编码上出错的概率相当且独立。试析多分类任务经 ECOC 编码后产生的二类分类器满足该条件的可能性及由此产生的影响。
**答：**   
条件分解为两个：一是出错的概率相当，二是出错的可能性相互独立。

先看第一个把，其实就是每个一位上的分类器的泛化误差相同，要满足这个条件其实取决于样本之间的区分难度，
若两个类别本身就十分相似，即越难区分，训练出的分类器出错的概率越大，原书p66也提到：
>将多个类拆解为两个"类别子集“，所形成的两个类别子集的区分难度往往不同，即其导致的二分类问题的难度不同。

所以每个编码拆解后类别之间的差异越相同（区分难度相当），则满足此条件的可能性越大。在实际中其实很难满足。

第二个，相互独立。在3.7中也提到过，原论文中也提出一个好的纠错输出码应该满足的其中一个条件就是各个位上分类器相互独立，
当类别越多时，满足这个条件的可能性越大，在3.7中也解释了当类别较少时，很难满足这个条件。

至于产生的影响。西瓜书上也提到：
>一个理论纠错牲质很好、但导致的三分类问题较难的编码，与另一个理论纠错性质差一些、但导致的二分类问题较简单的编码，最终产生的模型性能孰强孰弱很难说。

---

#### 3.9 使用 OvR 和 MvM 将多分类任务分解为二分类任务求解时，试述为何无需专门针对类别不平衡性进行处理。
**答：**

p66 其实已经给出答案了：
>对 OvR 、 MvM 来说，由于对每个类进行了相同的处理，其拆解出的二分类任务中类别不平衡的影响会相互抵消，因此通常不需专门处理.

---

#### 3.10 试推导出多分类代价敏感学习(仅考虑基于类别的误分类代价)使用"再缩放"能获得理论最优解的条件。
**答：**

这道题目其实是周志华教授的一篇论文《On Multi-Class Cost-Sensitive Learning》。把论文理论部分读了一遍。现在尝试概述一遍吧。

首先说一点关于“再缩放”的个人理解：无论是代价敏感学习还是非代价敏感学习中，“再缩放”各种方法（过采样、欠采样、阈值移动等）都是在调整各类别对模型的影响程度，即各类别的权重。

以 $ cost_{ij} $ 表示将 $ i $ 类样本误分类为 $ j $ 类样本的损失，那么在二分类的问题中，
$ p \ast cost_{11}+(1-p)cost_{21} $ 表示分类器将样本预测为1类的期望损失，其中 $ p=P(class=1|x) $ ，
那么当 $ p \ast cost_{11}+(1-p)cost_{21} < p \ast cost_{12}+(1-p) \ast cost_{22} $ 时即预测1类时的期望损失小于预测2类的期望损失，
那么将样本预测为1类根据合理，当取等号且假设正确分类时损失为0，
即可得到最优决策阈值有 $ \frac{p^{\ast}}{1-p^{\ast}}=\frac{cost_{21}}{cost_{12}} $ ，
即 $ p^{*}=\frac{cost_{21}}{cost_{12}+cost_{21}} $ 。在《On Multi-Class Cost-Sensitive Learning》中，
引用了另外一篇论文《The Foundations of Cost-Sensitive Learning》的一个理论：   
![7](https://github.com/han1057578619/MachineLearning_Zhouzhihua_ProblemSets/blob/master/ch3--%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/image/7.jpg)   
通过这个理论来推导出在代价敏感学习中，最优“再缩放”之后，各类别的权重应该满足的条件。
看了原论文才看懂这个理论表达的意思。。关于理论的证明有兴趣可以再看看原论文，这里就不再复述一遍了。
它想说的是，假设有一个算法 $ L $ 生成的分类器是以 $ p_{0} $ 为决策阈值，
那么如果当给定一个数据集 $ S $ 以及最优决策阈值 $ p^{\ast} $ ，这个理论表明通过增加负样本的数量，
使其是原来的 $ \frac{p^{\ast}}{1-p^{\ast}}\frac{1-p_{0}}{p_{0}} $ 倍，
创建数据集 $ S^{'} $ ， $ L $ 通过 $ S^{'} $ 依然能生成一个以 $ p_{0} $ 为决策阈值且足够好的分类器。
以二分类为例，当样本数量均衡时 $ p_{0}=0.5 $ 。那么根据此理论，
相比于一类，二类的再缩放比例应该为一类的 $ \frac{p^{\ast}}{1-p^{\ast}}=\frac{cost_{21}}{cost_{12}} $ 倍，
表示一类的影响力为二类影响力的 $ \frac{cost_{12}}{cost_{21}} $ 的倍。以 $ w_{i} $ 表示对第 $ i $ 的再缩放比率，
推广到多分类时“再缩放”获得最优理论解就应满足：   
![4](https://github.com/han1057578619/MachineLearning_Zhouzhihua_ProblemSets/blob/master/ch3--%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/image/4.jpg)   
即：   
![5](https://github.com/han1057578619/MachineLearning_Zhouzhihua_ProblemSets/blob/master/ch3--%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/image/5.jpg)   
方程组有解。   
![6](https://github.com/han1057578619/MachineLearning_Zhouzhihua_ProblemSets/blob/master/ch3--%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/image/6.jpg)   
其伴随矩阵秩小于c。